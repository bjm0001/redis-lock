# 1. 什么是分布式锁
线程锁时一个多线程可见的内存标记，保证同一个任务，同一时刻只能被多线程中的某一个执行。但是

这样的锁在分布式系统中，多进程环境下， 就达不到预期的效果了。

而如果我们 将这个标记变成多进程可见，保证这个任务同一时刻只能被多个进程中的某一个执行，那

这样的锁就是分布式锁 了。

# 2. 业务场景
我们假设一个这样的业务场景：  
在电商中，用户购买商品需要扣减商品库存，一般有两种扣减库存方式：  
- 下单减库存  
    - 优点：用户体验好，下单成功，库存直接扣除，用户支付不会出现库存不足情况  
    - 缺点：用户一直不付款，这个商品的库存就会被占用，其他人就无法购买了。  
- 支付减库存
    - 优点：不会导致库存被恶意锁定，对商家有利
    - 缺点：用户体验不好，用户支付时可能商品库存不足了，会导致用户交易失败



那么，我们一般为了用户体验，会采用下单减库存。但是为了解决下单减库存的缺陷，会创建一个定时
任务，定时去清理超时未支付的订单。
在这个定时任务中，需要完成的业务步骤主要包括：

1. 查询超时未支付订单，获取订单中商品信息
2. 修改这些未支付订单的状态，为已关闭
3. 恢复订单中商品扣减的库存

如图：

![](./doc\images\1.png)

但是，如果我们给订单服务搭建一个100台服务节点的集群，那么就会在同一时刻有100个定时任务触发

并执行，设想一下这样的场景：

- 订单服务A执行了步骤1，但还没有执行步骤B

- 订单服务B执行了步骤1，于是查询到了与订单服务A查询到的一样的数据

- 订单服务A执行步骤2和3，此时订单中对应商品的库存已经恢复了

- 订单服务B也执行了步骤2和步骤3，此时订单中对应商品的库存再次被增加

- 库存被错误的恢复了多次， 事实上只需要执行一次就可以了 。

就像这样：

![](./doc\images\2.png)

因为任务的并发执行，出现了线程安全问题，商品库存被错误的增加了多次，

# **3. 线程锁**

我们通常使用的synchronized或者Lock都是线程锁，对同一个JVM进程内的多个线程有效。因为锁的本质

是内存中存放一个标记，记录获取锁的线程时谁，**这个标记对每个线程都可见**。

获取锁：就是判断标记中是否已经有线程存在，如果有，则获取锁失败，如果没有，在标记中记录

当前线程

释放锁：就是删除标记中保存的线程，并唤醒等待队列中的其它线程

因此，锁生效的前提是：

- 互斥：锁的标记只有一个线程可以获取

- 共享：标记对所有线程可见

然而我们启动的多个订单服务，就是多个JVM，内存中的锁显然是不共享的，每个JVM进程都有自己的

锁，自然无法保证线程的互斥了，

如图

![](./doc\images\3.png)

分布式锁实现有多种方式，其原理都基本类似，只要满足下列要求即可：

- **多进程可见**：多进程可见，否则就无法实现分布式效果

- **互斥（）**：同一时刻，只能有一个进程获得锁，执行任务后释放锁

- 可重入（可选）：同一个任务再次获取改锁不会被死锁

- 阻塞锁（可选）：获取失败时，具备重试机制，尝试再次获取锁 （发布订阅 或者while）

- 性能好（可选）：效率高，应对高并发场景

- 高可用：避免锁服务宕机或处理好宕机的补救措施

常见的分布式锁实现方案包括： 基于数据库实现、基于缓存实现、基于zookeeper 等 

该分布式锁实现了如下功能：
1. 多进程可见，开启多个进程获取同一个共享锁
2. 互斥
# 安装
```
composer require qilim/redis-lock
```

# 使用
1. 加锁操作
```
include_once '../vendor/autoload.php';
$lock = \qiLin\redisLock\lock::getInstance();
$result = $lock->lock('lock', $pid, '300');
```
参数说明：

|参数 |类型 |是否必填 |说明|
|----|----|----|-----|
|lock|string|是|锁名称|
|pid|string|是|进程id|
|300|string|是|有效期：单位秒|




2. 释放锁
```
include_once '../vendor/autoload.php';
$lock = \qiLin\redisLock\lock::getInstance();
$result = $lock->unLock('lock', $pid, '300');
```
参数说明：

|参数 |类型 |是否必填 |说明|
|----|----|----|-----|
|lock|string|是|锁名称|
|pid|string|是|进程id|
|300|string|是|有效期：单位秒|
# 案例
 业务场景：模拟下单减库存操作
 
 1. redis设置库存数据量
 ```
 set stock 50
```
 2. 业务代码
 ```
<?php
include_once '../vendor/autoload.php';
$pid = getmypid();

$lock = \qiLin\redisLock\lock::getInstance();

//1.1 获取锁
$result = $lock->lock('lock', $pid, '300');
$stock = $lock->getRedisInstance()->get('stock');

//2.验证库存是否充足
if ($result && $stock <= 0) {
    $result = $lock->unLock('lock', $pid, '300');
    echo "扣减失败，库存不足";
    die();
}
// 3. 减少库存
$stock = $lock->getRedisInstance()->decrby('stock', '1');
echo $msg = "扣减成功，库存{$stock}" . PHP_EOL;
error_log($msg, '3', "a.log");

//4. 回收锁
$result = $lock->unLock('lock', $pid, '300');
```
3. 并发测试
测试一次51个请求

![](./doc\images\5.png)
 
查看倒数第二个请求成功，最后一个请求失败提示库存不足
![](./doc\images\6.png)
![](./doc\images\7.png)


